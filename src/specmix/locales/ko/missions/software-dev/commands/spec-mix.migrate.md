---
description: 추적되지 않은 커밋을 회고적 명세를 생성하여 스펙 기반 워크플로우로 마이그레이션합니다.
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## 사용자 입력

```text
{ARGS}
```

입력이 비어있지 않다면 **반드시** 진행하기 전에 사용자 입력을 고려해야 합니다.

## 개요

이 명령어는 작업 패키지 ID가 없는 기존 커밋을 스펙 기반 워크플로우로 마이그레이션하는 데 도움을 줍니다. 실제로 구현된 내용을 분석하고 회고적 명세를 생성합니다.

**입력**: 커밋 SHA (필수) - 마이그레이션할 커밋

커밋 SHA가 주어지면 다음을 수행합니다:

1. **커밋 SHA 검증**:
   ```bash
   git rev-parse --verify {COMMIT_SHA}
   ```
   - 유효하지 않은 경우: ERROR "유효하지 않은 커밋 SHA: {COMMIT_SHA}"
   - 유효한 경우: 분석 진행

2. **커밋 분석**:

   a. 커밋 메타데이터 가져오기:
      ```bash
      git show --format="%H|%s|%cd|%an|%ae" --date=iso-strict --no-patch {COMMIT_SHA}
      ```

   b. 커밋 diff와 변경된 파일 가져오기:
      ```bash
      git show {COMMIT_SHA} --stat
      git show {COMMIT_SHA}
      ```

   c. 구현 세부사항 추출:
      - 어떤 파일이 변경되었는지
      - 어떤 기능이 추가/수정/제거되었는지
      - 어떤 패턴이나 기술이 사용되었는지
      - 어떤 문제를 해결했는지

3. **피처 이름 생성**:
   - 커밋 메시지와 코드 변경 분석
   - 구현된 핵심 기능이나 수정 사항 추출
   - 다음 가이드라인에 따라 간결한 짧은 이름(2-4 단어) 생성:
     - 동작-명사 형식 사용: "add-user-auth", "fix-payment-bug"
     - 기술 용어와 약어는 그대로 유지
     - 예시:
       - "feat: WP04.3 JSON 스키마 검증기" → "json-schema-validator"
       - "fix: 대시보드 성능 이슈" → "fix-dashboard-performance"
       - "OAuth2 통합 추가" → "oauth2-integration"

4. **기존 브랜치 확인** (`/spec-mix.specify`와 동일):

   a. 모든 원격 브랜치 가져오기:
      ```bash
      git fetch --all --prune
      ```

   b. 이 short-name에 대한 가장 높은 피처 번호 찾기:
      - 원격 브랜치: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 로컬 브랜치: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - specs 디렉토리: `specs/[0-9]+-<short-name>` 확인

   c. 다음 번호(N+1) 결정하고 스크립트 실행:
      ```bash
      {SCRIPT} --json --number {N+1} --short-name "{short-name}" "커밋 {SHORT_SHA}에서 마이그레이션됨"
      ```

5. **템플릿 로드**:
   - `.spec-mix/active-mission/templates/spec-template.md` 로드
   - `.spec-mix/active-mission/templates/plan-template.md` 로드
   - `.spec-mix/active-mission/templates/tasks-template.md` 로드

6. **프로젝트 헌법 로드** (존재하는 경우):
   - `specs/constitution.md`를 읽어 프로젝트 원칙 이해
   - 회고적 명세가 프로젝트 거버넌스와 일치하는지 확인

7. **회고적 명세 생성**:

   커밋에서 발견된 실제 구현을 기반으로:

   a. **기능 개요**:
      - 실제로 구현된 내용에서 기능의 목적 도출
      - 제공된 솔루션에서 사용자 요구사항 추론
      - 이 커밋이 해결한 문제 문서화

   b. **기능 요구사항**:
      - 코드가 실제로 하는 일 나열 (구현에서 역설계)
      - 기술적 변경을 사용자 관점의 요구사항으로 변환
      - 예: "JWT 미들웨어 추가" → "사용자는 안전하게 인증할 수 있음"

   c. **사용자 시나리오 및 테스트**:
      - 구현에서 사용자 플로우 추론
      - 실제로 구축된 것에서 테스트 케이스 도출

   d. **성공 기준**:
      - 제공된 것을 기반으로 측정 가능한 결과 정의
      - 가능한 한 기술 중립적으로 유지

   e. **주요 엔티티** (해당하는 경우):
      - 커밋에서 도입된 데이터 모델이나 엔티티 문서화

   f. **가정사항**:
      - 코드에서 추론한 내용 문서화
      - 요구사항 역설계의 모호성 기록

   **중요**: 이것은 회고적 명세이므로:
   - 이 구현으로 이어진 요구사항을 문서화하는 것처럼 작성
   - 합리적인 수준에서 기술 중립적으로 유지 (WHAT 설명, HOW가 아님)
   - 역설계한 섹션에는 `[구현에서 추론됨]` 표시
   - 코드나 구현 세부사항을 명세에 복사하지 않음

8. **회고적 계획 생성**:

   실제로 구현된 방식을 기반으로:

   a. **기술 컨텍스트**:
      - 커밋에서 실제로 사용된 기술과 프레임워크 나열
      - 코드에서 관찰된 아키텍처 패턴 문서화

   b. **구현 접근방식**:
      - 실제로 구축된 솔루션 설명
      - 코드에서 명백한 주요 설계 결정 문서화

   c. **구현 단계**:
      - 수행된 작업을 논리적 단계로 분해
      - 코드 변경을 구현 단계에 매핑

   d. **테스트 전략**:
      - 테스트 파일(있는 경우)에서 테스트 접근방식 추론
      - 구축된 것을 기반으로 테스트 전략 제안

   **중요**: 이것은 회고적 계획이므로:
   - 해야 했던 것이 아니라 실제로 수행된 것을 문서화
   - 섹션에 `[완료됨]`을 표시하여 사후 구현임을 나타냄
   - 커밋의 실제 파일 경로와 컴포넌트 포함

9. **회고적 작업 생성**:

   실제로 구현된 것을 기반으로 작업 분해 생성:

   a. 커밋 변경사항을 분석하고 논리적 작업으로 그룹화

   b. 각 작업에 대해 작업 패키지 파일 생성:
      - `work-package-template.md`의 템플릿 구조 사용
      - 상태를 `done`으로 표시 (작업이 이미 완료되었으므로)
      - 설명에 실제 코드 변경 포함
      - 커밋 SHA 참조

   c. 모든 작업을 `tasks/done/` 레인에 배치 (이미 완료되었으므로)

   d. 작업 구조 예시:
      ```markdown
      # WP01: [작업 이름]

      **상태**: done
      **마이그레이션 원본**: {COMMIT_SHA}
      **완료일**: {COMMIT_DATE}

      ## 설명
      [diff에서 도출한 실제로 구현된 내용]

      ## 수락 기준
      - [x] [실제 변경사항을 기반으로 한 기준]

      ## 구현 노트
      변경된 파일:
      - path/to/file1.js (+50, -10)
      - path/to/file2.css (+20, -5)

      ## 활동 로그
      - {COMMIT_DATE}: {AUTHOR}가 커밋 {COMMIT_SHA}에서 마이그레이션
      ```

10. **파일 쓰기**:

    a. 명세를 `SPEC_FILE`에 쓰기 (스크립트 출력에서)

    b. 계획을 `FEATURE_DIR/plan.md`에 쓰기

    c. 작업을 `FEATURE_DIR/tasks/done/WP##.md`에 쓰기

    d. 마이그레이션 메타데이터 생성:
       ```bash
       echo "마이그레이션 원본 커밋: {COMMIT_SHA}" > FEATURE_DIR/.migration-info
       echo "원본 커밋 날짜: {COMMIT_DATE}" >> FEATURE_DIR/.migration-info
       echo "원본 작성자: {AUTHOR}" >> FEATURE_DIR/.migration-info
       ```

11. **결과 발표**:

    사용자에게 요약 발표:

    ```markdown
    ## 마이그레이션 완료

    커밋 `{SHORT_SHA}`를 스펙 기반 워크플로우로 성공적으로 마이그레이션했습니다.

    **원본 커밋**:
    - SHA: {COMMIT_SHA}
    - 메시지: {COMMIT_MESSAGE}
    - 작성자: {AUTHOR}
    - 날짜: {COMMIT_DATE}

    **새 피처**:
    - 브랜치: {BRANCH_NAME}
    - 명세: {SPEC_FILE}
    - 계획: {PLAN_FILE}
    - 작업: `tasks/done/`에 {TASK_COUNT}개 작업

    **생성된 내용**:
    - 회고적 명세 (구현에서 역설계됨)
    - 회고적 계획 (실제로 구축된 것을 문서화)
    - 작업 패키지 (완료로 표시, 실제 변경사항 포함)

    **다음 단계**:
    1. 생성된 명세/계획/작업의 정확성 검토
    2. 필요한 경우 [구현에서 추론됨] 섹션 업데이트
    3. 이 피처를 연결하는 새 커밋 생성 고려:
       ```bash
       git commit --allow-empty -m "docs: 커밋 {SHORT_SHA}를 피처 {BRANCH_NAME}에 연결"
       ```

    **참고**: 원본 커밋은 git 히스토리에 변경 없이 유지됩니다. 이 마이그레이션은 추적 목적의 문서를 생성합니다.
    ```

12. **선택사항: Cherry-Pick 제안** (main 브랜치에 있는 경우):

    원본 커밋이 main 브랜치에 있고 사용자가 히스토리를 정리하려는 경우:

    ```markdown
    ## 선택사항: Git 히스토리 재구성

    이 커밋을 피처 브랜치로 이동하려면:

    ```bash
    # 커밋을 피처 브랜치로 cherry-pick
    git checkout {BRANCH_NAME}
    git cherry-pick {COMMIT_SHA}

    # 커밋 메시지를 업데이트하여 WP ID 포함
    git commit --amend -m "{COMMIT_MESSAGE} [WP01]"
    ```

    **경고**: 다음 경우에만 수행하세요:
    - 커밋이 아직 원격에 푸시되지 않은 경우
    - git 히스토리 재작성에 익숙한 경우
    - 커밋이 독립적인 경우 (종속 커밋이 없음)
    ```

## 일반 가이드라인

### 코드에서 역설계하기

커밋에서 회고적 명세를 생성할 때:

1. **사용자 가치에 집중**: 코드 변경만 설명하지 말고 사용자 요구사항 추론
   - 나쁨: "JWT 미들웨어 함수 추가"
   - 좋음: "사용자는 보호된 리소스에 접근하기 위해 안전한 인증이 필요함"

2. **구현 추상화**: 기술적 세부사항을 요구사항으로 변환
   - 코드가 보여주는 것: 데이터베이스 스키마 변경
   - 명세가 보여주는 것: "시스템은 사용자 선호사항을 지속해야 함"

3. **의도 추론**: 커밋 메시지, 코드 주석, 패턴을 사용하여 목적 이해
   - "왜"를 설명하는 TODO, FIXME, 주석 찾기
   - 예상 동작을 이해하기 위해 테스트 케이스 분석

4. **불확실성 표시**: 역설계할 때 `[구현에서 추론됨]` 사용
   - "이것은 [문제]를 해결하는 것으로 보임 [구현에서 추론됨]"
   - 가정에 대해 정직하기

### 품질 검증

회고적 문서 생성 후:

1. **명세는 기술 중립적이어야 함** (코드를 봤더라도)
2. **계획은 실제 사용된 기술을 문서화**
3. **작업은 실제 파일과 변경사항 참조**
4. **모든 문서는 회고적/완료로 표시**

### 일반적인 마이그레이션 시나리오

**시나리오 1: 기능 추가**
- 커밋이 새 기능 추가
- 기능을 설명하는 명세 생성
- 계획은 어떻게 구축되었는지 문서화
- 작업은 구현 단계 포함

**시나리오 2: 버그 수정**
- 커밋이 버그 수정
- "버그: [설명]"으로 명세 생성
- 계획은 수정 접근방식 문서화
- 수정을 위한 단일 작업

**시나리오 3: 리팩토링**
- 커밋이 코드 구조 개선
- "기술 개선: [목표]"로 명세 생성
- 계획은 리팩토링 접근방식 문서화
- 작업은 리팩토링 단계 포함

**시나리오 4: 여러 기능**
- 커밋이 관련 없는 여러 변경사항 포함
- 여러 피처로 분할 제안:
  ```
  마이그레이션 불가: 커밋이 관련 없는 여러 변경사항을 포함합니다.
  다음을 위해 별도의 피처를 생성하세요:
  1. [파일 그룹 A에 기반한 기능 1]
  2. [파일 그룹 B에 기반한 기능 2]

  먼저 git 도구를 사용하여 커밋을 분할하는 것을 고려하세요.
  ```